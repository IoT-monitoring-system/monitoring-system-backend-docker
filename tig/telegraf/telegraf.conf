# Global tags can be specified here in key="value" format.
[global_tags]
  # dc = "us-east-1" # will tag all metrics with dc=us-east-1
  # rack = "1a"
  ## Environment variables can be used as tags, and throughout the config file
  # user = "$USER"


# Configuration for telegraf agent
[agent]
  interval = "10s"
  round_interval = true
  metric_batch_size = 1000
  metric_buffer_limit = 10000
  collection_jitter = "0s"
  flush_interval = "10s"  # Maximum flush_interval will be flush_interval + flush_jitter
  flush_jitter = "0s"
  precision = "1ms"
  hostname = ""
  omit_hostname = false
  debug = true
  quiet = false
  logfile = ""


###############################################################################
#                            OUTPUT PLUGINS                                   #
###############################################################################
# Configuration for sending metrics to InfluxDB 2.0
[[outputs.influxdb_v2]]
  urls = ["http://influxdb:8086"]

  ## Organization is the name of the organization you wish to write to.
  organization = "shtuk-org"

  ## Timeout for HTTP messages.
  timeout = "5s"

  ## HTTP User-Agent
  user_agent = "telegraf"

  ## Content-Encoding for write request body, can be set to "gzip" to
  ## compress body or "identity" to apply no encoding.
  content_encoding = "gzip"

  ## Enable or disable uint support for writing uints influxdb 2.0.
  influx_uint_support = true

  ## Destination bucket to write into.
  bucket = "IoT-Monitoring-System"

  ## Additional HTTP headers
  # http_headers = {"X-Special-Header" = "Special-Value"}
  
  ## Token for authentication.
  token = "f4_D2MhgYIfB0Fm_hjLamgC9_YrYX5vtpo-VqR6ZQT7p9wqqps6c1K7PmQqzVvgIiHFo_-Q51o6PubRPGwfHIg=="

[[processors.starlark]]
    source = '''
load("logging.star", "log")

def apply(metric):
    keys_to_drop = []

    for key, value in metric.fields.items():
        str_value = str(value)
        
        if "Inf" in str_value or str_value in ("NaN", "+Inf", "-Inf"):
            keys_to_drop.append(key)
            log.warn("Dropping bad value: metric '{}' field '{}' had value '{}'".format(metric.name, key, str_value))

    for key in keys_to_drop:
        metric.fields.pop(key)

    return metric'''

###############################################################################
#                            SERVICE INPUT PLUGINS                            #
###############################################################################

# # Read metrics from MQTT topic(s)
[[inputs.mqtt_consumer]]
  servers = ["tcp://192.168.0.123:1883"]

  topics = [
    "/IoT-Monitoring-System/#",
  ]

  topic_tag = "topic"

  qos = 2

  connection_timeout = "30s"

#   ## Maximum messages to read from the broker that have not been written by an
#   ## output.  For best throughput set based on the number of metrics within
#   ## each message and the size of the output's metric_batch_size.
#   ##
#   ## For example, if each message from the queue contains 10 metrics and the
#   ## output metric_batch_size is 1000, setting this to 100 will ensure that a
#   ## full batch is collected and the write is triggered immediately without
#   ## waiting until the next flush_interval.
#   # max_undelivered_messages = 1000

  persistent_session = true

  client_id = "telegraf-client_iot_monitor_sys"
  username = "telegraf2"
  password = "Test12345"

  data_format = "xpath_cbor"

  xpath_print_document = true
  xpath_native_types = true
  
  [[inputs.mqtt_consumer.xpath]]
    metric_selection = "/data/sensor_data"
	
    timestamp = "timestamp"
    timestamp_format = "unix_us"

    field_selection  = "fields/*[name() != 'gas_idx']"
    field_name       = "name()"
    field_value      = "number(.)"

    [inputs.mqtt_consumer.xpath.tags]
      sensor   = "string(sensor)"
      deviceId = "string(../deviceId)"
      gas_idx  = "string(fields/gas_idx)"